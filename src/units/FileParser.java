//=========================================================================
//
//  This file was generated by Mouse 1.5 at 2012-04-06 19:20:20 GMT
//  from grammar 'D:\Units\ units\FileGrammar.peg'.
//
//=========================================================================

package units;

import units.Source;

public class FileParser extends units.ParserMemo
{
  final FileSemantics sem;
  
  //=======================================================================
  //
  //  Initialization
  //
  //=======================================================================
  //-------------------------------------------------------------------
  //  Constructor
  //-------------------------------------------------------------------
  public FileParser()
    {
      sem = new FileSemantics();
      sem.rule = this;
      super.sem = sem;
      caches = cacheList;
    }
  
  //-------------------------------------------------------------------
  //  Run the parser
  //-------------------------------------------------------------------
  public boolean parse(Source src)
    {
      super.init(src);
      sem.init();
      if (line()) return true;
      return failure();
    }
  
  //-------------------------------------------------------------------
  //  Get semantics
  //-------------------------------------------------------------------
  public FileSemantics semantics()
    { return sem; }
  
  //=======================================================================
  //
  //  Parsing procedures
  //
  //=======================================================================
  //=====================================================================
  //  line = "!" command / space definition ;
  //=====================================================================
  private boolean line()
    {
      if (saved(line)) return reuse();
      if (line_0()) return accept();
      if (line_1()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  line_0 = "!" command
  //-------------------------------------------------------------------
  private boolean line_0()
    {
      if (savedInner(line_0)) return reuseInner();
      if (!next('!')) return rejectInner();
      if (!command()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  line_1 = space definition
  //-------------------------------------------------------------------
  private boolean line_1()
    {
      if (savedInner(line_1)) return reuseInner();
      space();
      if (!definition()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  command = "locale " argument EOL {locale} / "locale" EOL {badloc} /
  //    "endlocale" EOL {endlocale} / "include " argument EOL {include} /
  //    "include" EOL {badincl} / "unitlist " space name space argument
  //    EOL {unitlist} / "unitlist" space EOL {badlist} / "utf8" EOL /
  //    "endutf8" EOL / skip EOL {badcomm} ;
  //=====================================================================
  private boolean command()
    {
      if (saved(command)) return reuse();
      if (command_0())
      { sem.locale(); return accept(); }
      if (command_1())
      { sem.badloc(); return accept(); }
      if (command_2())
      { sem.endlocale(); return accept(); }
      if (command_3())
      { sem.include(); return accept(); }
      if (command_4())
      { sem.badincl(); return accept(); }
      if (command_5())
      { sem.unitlist(); return accept(); }
      if (command_6())
      { sem.badlist(); return accept(); }
      if (command_7()) return accept();
      if (command_8()) return accept();
      if (command_9())
      { sem.badcomm(); return accept(); }
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  command_0 = "locale " argument EOL
  //-------------------------------------------------------------------
  private boolean command_0()
    {
      if (savedInner(command_0)) return reuseInner();
      if (!next("locale ")) return rejectInner();
      argument();
      if (!EOL()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  command_1 = "locale" EOL
  //-------------------------------------------------------------------
  private boolean command_1()
    {
      if (savedInner(command_1)) return reuseInner();
      if (!next("locale")) return rejectInner();
      if (!EOL()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  command_2 = "endlocale" EOL
  //-------------------------------------------------------------------
  private boolean command_2()
    {
      if (savedInner(command_2)) return reuseInner();
      if (!next("endlocale")) return rejectInner();
      if (!EOL()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  command_3 = "include " argument EOL
  //-------------------------------------------------------------------
  private boolean command_3()
    {
      if (savedInner(command_3)) return reuseInner();
      if (!next("include ")) return rejectInner();
      argument();
      if (!EOL()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  command_4 = "include" EOL
  //-------------------------------------------------------------------
  private boolean command_4()
    {
      if (savedInner(command_4)) return reuseInner();
      if (!next("include")) return rejectInner();
      if (!EOL()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  command_5 = "unitlist " space name space argument EOL
  //-------------------------------------------------------------------
  private boolean command_5()
    {
      if (savedInner(command_5)) return reuseInner();
      if (!next("unitlist ")) return rejectInner();
      space();
      if (!name()) return rejectInner();
      space();
      argument();
      if (!EOL()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  command_6 = "unitlist" space EOL
  //-------------------------------------------------------------------
  private boolean command_6()
    {
      if (savedInner(command_6)) return reuseInner();
      if (!next("unitlist")) return rejectInner();
      space();
      if (!EOL()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  command_7 = "utf8" EOL
  //-------------------------------------------------------------------
  private boolean command_7()
    {
      if (savedInner(command_7)) return reuseInner();
      if (!next("utf8")) return rejectInner();
      if (!EOL()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  command_8 = "endutf8" EOL
  //-------------------------------------------------------------------
  private boolean command_8()
    {
      if (savedInner(command_8)) return reuseInner();
      if (!next("endutf8")) return rejectInner();
      if (!EOL()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  command_9 = skip EOL
  //-------------------------------------------------------------------
  private boolean command_9()
    {
      if (savedInner(command_9)) return reuseInner();
      skip();
      if (!EOL()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  definition = name [ \t] def EOL {unitdef} / name "(" param ")"
  //    space "[" dim ";" dim "]" def (";" def)? EOL {funcdef1} / name
  //    "(" param ")" space "[" skip EOL {baddim} / name "(" param ")"
  //    def (";" def)? EOL {funcdef2} / name "(" skip EOL {badfunc} /
  //    name "[" tabunit "]" space pair+ EOL {tabdef} / name "[" skip EOL
  //    {badtab} / name EOL {badunit} / EOL ;
  //=====================================================================
  private boolean definition()
    {
      if (saved(definition)) return reuse();
      if (definition_0())
      { sem.unitdef(); return accept(); }
      if (definition_1())
      { sem.funcdef1(); return accept(); }
      if (definition_2())
      { sem.baddim(); return accept(); }
      if (definition_3())
      { sem.funcdef2(); return accept(); }
      if (definition_4())
      { sem.badfunc(); return accept(); }
      if (definition_5())
      { sem.tabdef(); return accept(); }
      if (definition_6())
      { sem.badtab(); return accept(); }
      if (definition_7())
      { sem.badunit(); return accept(); }
      if (EOL()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  definition_0 = name [ \t] def EOL
  //-------------------------------------------------------------------
  private boolean definition_0()
    {
      if (savedInner(definition_0)) return reuseInner();
      if (!name()) return rejectInner();
      if (!nextIn(" \t")) return rejectInner();
      def();
      if (!EOL()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  definition_1 = name "(" param ")" space "[" dim ";" dim "]" def
  //    (";" def)? EOL
  //-------------------------------------------------------------------
  private boolean definition_1()
    {
      if (savedInner(definition_1)) return reuseInner();
      if (!name()) return rejectInner();
      if (!next('(')) return rejectInner();
      if (!param()) return rejectInner();
      if (!next(')')) return rejectInner();
      space();
      if (!next('[')) return rejectInner();
      dim();
      if (!next(';')) return rejectInner();
      dim();
      if (!next(']')) return rejectInner();
      def();
      definition_8();
      if (!EOL()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  definition_2 = name "(" param ")" space "[" skip EOL
  //-------------------------------------------------------------------
  private boolean definition_2()
    {
      if (savedInner(definition_2)) return reuseInner();
      if (!name()) return rejectInner();
      if (!next('(')) return rejectInner();
      if (!param()) return rejectInner();
      if (!next(')')) return rejectInner();
      space();
      if (!next('[')) return rejectInner();
      skip();
      if (!EOL()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  definition_3 = name "(" param ")" def (";" def)? EOL
  //-------------------------------------------------------------------
  private boolean definition_3()
    {
      if (savedInner(definition_3)) return reuseInner();
      if (!name()) return rejectInner();
      if (!next('(')) return rejectInner();
      if (!param()) return rejectInner();
      if (!next(')')) return rejectInner();
      def();
      definition_8();
      if (!EOL()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  definition_4 = name "(" skip EOL
  //-------------------------------------------------------------------
  private boolean definition_4()
    {
      if (savedInner(definition_4)) return reuseInner();
      if (!name()) return rejectInner();
      if (!next('(')) return rejectInner();
      skip();
      if (!EOL()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  definition_5 = name "[" tabunit "]" space pair+ EOL
  //-------------------------------------------------------------------
  private boolean definition_5()
    {
      if (savedInner(definition_5)) return reuseInner();
      if (!name()) return rejectInner();
      if (!next('[')) return rejectInner();
      if (!tabunit()) return rejectInner();
      if (!next(']')) return rejectInner();
      space();
      if (!pair()) return rejectInner();
      while (pair());
      if (!EOL()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  definition_6 = name "[" skip EOL
  //-------------------------------------------------------------------
  private boolean definition_6()
    {
      if (savedInner(definition_6)) return reuseInner();
      if (!name()) return rejectInner();
      if (!next('[')) return rejectInner();
      skip();
      if (!EOL()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  definition_7 = name EOL
  //-------------------------------------------------------------------
  private boolean definition_7()
    {
      if (savedInner(definition_7)) return reuseInner();
      if (!name()) return rejectInner();
      if (!EOL()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  definition_8 = ";" def
  //-------------------------------------------------------------------
  private boolean definition_8()
    {
      if (savedInner(definition_8)) return reuseInner();
      if (!next(';')) return rejectInner();
      def();
      return acceptInner();
    }
  
  //=====================================================================
  //  argument = _* ;
  //=====================================================================
  private boolean argument()
    {
      if (saved(argument)) return reuse();
      while (next());
      return accept();
    }
  
  //=====================================================================
  //  def = ^[;]* ;
  //=====================================================================
  private boolean def()
    {
      if (saved(def)) return reuse();
      while (nextNot(';'));
      return accept();
    }
  
  //=====================================================================
  //  name = ^[[( \t]+ ;
  //=====================================================================
  private boolean name()
    {
      if (saved(name)) return reuse();
      if (!nextNotIn("[( \t")) return reject();
      while (nextNotIn("[( \t"));
      return accept();
    }
  
  //=====================================================================
  //  param = ^[)]+ ;
  //=====================================================================
  private boolean param()
    {
      if (saved(param)) return reuse();
      if (!nextNot(')')) return reject();
      while (nextNot(')'));
      return accept();
    }
  
  //=====================================================================
  //  tabunit = ^[]]+ ;
  //=====================================================================
  private boolean tabunit()
    {
      if (saved(tabunit)) return reuse();
      if (!nextNot(']')) return reject();
      while (nextNot(']'));
      return accept();
    }
  
  //=====================================================================
  //  dim = ^[];]* ;
  //=====================================================================
  private boolean dim()
    {
      if (saved(dim)) return reuse();
      while (nextNotIn("];"));
      return accept();
    }
  
  //=====================================================================
  //  pair = number number ("," space)? {pair} ;
  //=====================================================================
  private boolean pair()
    {
      if (saved(pair)) return reuse();
      if (!number()) return reject();
      if (!number()) return reject();
      pair_0();
      sem.pair();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  pair_0 = "," space
  //-------------------------------------------------------------------
  private boolean pair_0()
    {
      if (savedInner(pair_0)) return reuseInner();
      if (!next(',')) return rejectInner();
      space();
      return acceptInner();
    }
  
  //=====================================================================
  //  number = sign? mantissa exponent? space {number} ;
  //=====================================================================
  private boolean number()
    {
      if (saved(number)) return reuse();
      sign();
      if (!mantissa()) return reject();
      exponent();
      space();
      sem.number();
      return accept();
    }
  
  //=====================================================================
  //  mantissa = "." digits / digits ("." digits?)? ;
  //=====================================================================
  private boolean mantissa()
    {
      if (saved(mantissa)) return reuse();
      if (mantissa_0()) return accept();
      if (mantissa_1()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  mantissa_0 = "." digits
  //-------------------------------------------------------------------
  private boolean mantissa_0()
    {
      if (savedInner(mantissa_0)) return reuseInner();
      if (!next('.')) return rejectInner();
      if (!digits()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  mantissa_1 = digits ("." digits?)?
  //-------------------------------------------------------------------
  private boolean mantissa_1()
    {
      if (savedInner(mantissa_1)) return reuseInner();
      if (!digits()) return rejectInner();
      mantissa_2();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  mantissa_2 = "." digits?
  //-------------------------------------------------------------------
  private boolean mantissa_2()
    {
      if (savedInner(mantissa_2)) return reuseInner();
      if (!next('.')) return rejectInner();
      digits();
      return acceptInner();
    }
  
  //=====================================================================
  //  exponent = [Ee] sign? digits ;
  //=====================================================================
  private boolean exponent()
    {
      if (saved(exponent)) return reuse();
      if (!nextIn("Ee")) return reject();
      sign();
      if (!digits()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  sign = [+-] <sign> ;
  //=====================================================================
  private boolean sign()
    {
      if (saved(sign)) return reuse();
      if (!nextIn("+-")) return reject();
      return accept();
    }
  
  //=====================================================================
  //  digits = [0-9]+ ;
  //=====================================================================
  private boolean digits()
    {
      if (saved(digits)) return reuse();
      if (!nextIn('0','9')) return reject();
      while (nextIn('0','9'));
      return accept();
    }
  
  //=====================================================================
  //  space = [ \t]* ;
  //=====================================================================
  private boolean space()
    {
      if (saved(space)) return reuse();
      while (nextIn(" \t"));
      return accept();
    }
  
  //=====================================================================
  //  skip = _* ;
  //=====================================================================
  private boolean skip()
    {
      if (saved(skip)) return reuse();
      while (next());
      return accept();
    }
  
  //=====================================================================
  //  EOL = !_ ;
  //=====================================================================
  private boolean EOL()
    {
      if (saved(EOL)) return reuse();
      if (!aheadNot()) return reject();
      return accept();
    }
  
  //=======================================================================
  //
  //  Cache objects
  //
  //=======================================================================
  
  final Cache line = new Cache("line","line");
  final Cache command = new Cache("command","command");
  final Cache definition = new Cache("definition","definition");
  final Cache argument = new Cache("argument","argument");
  final Cache def = new Cache("def","def");
  final Cache name = new Cache("name","name");
  final Cache param = new Cache("param","param");
  final Cache tabunit = new Cache("tabunit","tabunit");
  final Cache dim = new Cache("dim","dim");
  final Cache pair = new Cache("pair","pair");
  final Cache number = new Cache("number","number");
  final Cache mantissa = new Cache("mantissa","mantissa");
  final Cache exponent = new Cache("exponent","exponent");
  final Cache sign = new Cache("sign","sign");
  final Cache digits = new Cache("digits","digits");
  final Cache space = new Cache("space","space");
  final Cache skip = new Cache("skip","skip");
  final Cache EOL = new Cache("EOL","EOL");
  
  final Cache line_0 = new Cache("line_0"); // "!" command
  final Cache line_1 = new Cache("line_1"); // space definition
  final Cache command_0 = new Cache("command_0"); // "locale " argument EOL
  final Cache command_1 = new Cache("command_1"); // "locale" EOL
  final Cache command_2 = new Cache("command_2"); // "endlocale" EOL
  final Cache command_3 = new Cache("command_3"); // "include " argument EOL
  final Cache command_4 = new Cache("command_4"); // "include" EOL
  final Cache command_5 = new Cache("command_5"); // "unitlist " space name space argument EOL
  final Cache command_6 = new Cache("command_6"); // "unitlist" space EOL
  final Cache command_7 = new Cache("command_7"); // "utf8" EOL
  final Cache command_8 = new Cache("command_8"); // "endutf8" EOL
  final Cache command_9 = new Cache("command_9"); // skip EOL
  final Cache definition_0 = new Cache("definition_0"); // name [ \t] def EOL
  final Cache definition_1 = new Cache("definition_1"); // name "(" param ")" space "[" dim ";" dim "]" def (";" def)? EOL
  final Cache definition_2 = new Cache("definition_2"); // name "(" param ")" space "[" skip EOL
  final Cache definition_3 = new Cache("definition_3"); // name "(" param ")" def (";" def)? EOL
  final Cache definition_4 = new Cache("definition_4"); // name "(" skip EOL
  final Cache definition_5 = new Cache("definition_5"); // name "[" tabunit "]" space pair+ EOL
  final Cache definition_6 = new Cache("definition_6"); // name "[" skip EOL
  final Cache definition_7 = new Cache("definition_7"); // name EOL
  final Cache definition_8 = new Cache("definition_8"); // ";" def
  final Cache pair_0 = new Cache("pair_0"); // "," space
  final Cache mantissa_0 = new Cache("mantissa_0"); // "." digits
  final Cache mantissa_1 = new Cache("mantissa_1"); // digits ("." digits?)?
  final Cache mantissa_2 = new Cache("mantissa_2"); // "." digits?
  
  //-------------------------------------------------------------------
  //  List of Cache objects
  //-------------------------------------------------------------------
  
  Cache[] cacheList =
  {
    line,command,definition,argument,def,name,param,tabunit,dim,pair,
    number,mantissa,exponent,sign,digits,space,skip,EOL,line_0,line_1,
    command_0,command_1,command_2,command_3,command_4,command_5,
    command_6,command_7,command_8,command_9,definition_0,definition_1,
    definition_2,definition_3,definition_4,definition_5,definition_6,
    definition_7,definition_8,pair_0,mantissa_0,mantissa_1,mantissa_2
  };
}
