//=========================================================================
//
//  This file was generated by Mouse 1.5 at 2012-04-06 19:20:20 GMT
//  from grammar 'D:\Units\ units\Grammar.peg'.
//
//=========================================================================

package units;

import units.Source;

public class Parser extends units.ParserBase
{
  final Semantics sem;
  
  //=======================================================================
  //
  //  Initialization
  //
  //=======================================================================
  //-------------------------------------------------------------------
  //  Constructor
  //-------------------------------------------------------------------
  public Parser()
    {
      sem = new Semantics();
      sem.rule = this;
      super.sem = sem;
    }
  
  //-------------------------------------------------------------------
  //  Run the parser
  //-------------------------------------------------------------------
  public boolean parse(Source src)
    {
      super.init(src);
      sem.init();
      if (unitexpr()) return true;
      return failure();
    }
  
  //-------------------------------------------------------------------
  //  Get semantics
  //-------------------------------------------------------------------
  public Semantics semantics()
    { return sem; }
  
  //=======================================================================
  //
  //  Parsing procedures
  //
  //=======================================================================
  //=====================================================================
  //  unitexpr = space expr? EOT {unitexpr} ~{error} ;
  //=====================================================================
  private boolean unitexpr()
    {
      begin("unitexpr");
      if (unitexpr_0())
      { sem.unitexpr(); return accept(); }
      else sem.error();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  unitexpr_0 = space expr? EOT
  //-------------------------------------------------------------------
  private boolean unitexpr_0()
    {
      begin("");
      space();
      expr();
      if (!EOT()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  expr = term ((PLUS / MINUS) term)* {expr} / (SLASH / PER) product
  //    {inverse} ;
  //=====================================================================
  private boolean expr()
    {
      begin("expr");
      if (expr_0())
      { sem.expr(); return accept(); }
      if (expr_1())
      { sem.inverse(); return accept(); }
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  expr_0 = term ((PLUS / MINUS) term)*
  //-------------------------------------------------------------------
  private boolean expr_0()
    {
      begin("");
      if (!term()) return rejectInner();
      while (expr_2());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  expr_1 = (SLASH / PER) product
  //-------------------------------------------------------------------
  private boolean expr_1()
    {
      begin("");
      if (!SLASH()
       && !PER()
         ) return rejectInner();
      if (!product()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  expr_2 = (PLUS / MINUS) term
  //-------------------------------------------------------------------
  private boolean expr_2()
    {
      begin("");
      if (!PLUS()
       && !MINUS()
         ) return rejectInner();
      if (!term()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  term = product ((STAR / SLASH / PER) product)* {term} ;
  //=====================================================================
  private boolean term()
    {
      begin("term");
      if (!product()) return reject();
      while (term_0());
      sem.term();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  term_0 = (STAR / SLASH / PER) product
  //-------------------------------------------------------------------
  private boolean term_0()
    {
      begin("");
      if (!STAR()
       && !SLASH()
       && !PER()
         ) return rejectInner();
      if (!product()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  product = factor (![+-] factor)* {product} ;
  //=====================================================================
  private boolean product()
    {
      begin("product");
      if (!factor()) return reject();
      while (product_0());
      sem.product();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  product_0 = ![+-] factor
  //-------------------------------------------------------------------
  private boolean product_0()
    {
      begin("");
      if (!aheadNotIn("+-")) return rejectInner();
      if (!factor()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  factor = unary ((HAT / STARSTAR) unary)* {factor} ;
  //=====================================================================
  private boolean factor()
    {
      begin("factor");
      if (!unary()) return reject();
      while (factor_0());
      sem.factor();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  factor_0 = (HAT / STARSTAR) unary
  //-------------------------------------------------------------------
  private boolean factor_0()
    {
      begin("");
      if (!HAT()
       && !STARSTAR()
         ) return rejectInner();
      if (!unary()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  unary = (PLUS / MINUS)? primary {unary} ;
  //=====================================================================
  private boolean unary()
    {
      begin("unary");
      unary_0();
      if (!primary()) return reject();
      sem.unary();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  unary_0 = PLUS / MINUS
  //-------------------------------------------------------------------
  private boolean unary_0()
    {
      begin("");
      if (PLUS()) return acceptInner();
      if (MINUS()) return acceptInner();
      return rejectInner();
    }
  
  //=====================================================================
  //  primary = numexpr {makeNumUnit} / LPAR expr RPAR {pass2} / unitname
  //    {pass} / bfunc LPAR expr RPAR {evalBfunc} / opttilde dfunc LPAR
  //    expr RPAR {evalUfunc} ;
  //=====================================================================
  private boolean primary()
    {
      begin("primary");
      if (numexpr())
      { sem.makeNumUnit(); return accept(); }
      if (primary_0())
      { sem.pass2(); return accept(); }
      if (unitname())
      { sem.pass(); return accept(); }
      if (primary_1())
      { sem.evalBfunc(); return accept(); }
      if (primary_2())
      { sem.evalUfunc(); return accept(); }
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  primary_0 = LPAR expr RPAR
  //-------------------------------------------------------------------
  private boolean primary_0()
    {
      begin("");
      if (!LPAR()) return rejectInner();
      if (!expr()) return rejectInner();
      if (!RPAR()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  primary_1 = bfunc LPAR expr RPAR
  //-------------------------------------------------------------------
  private boolean primary_1()
    {
      begin("");
      if (!bfunc()) return rejectInner();
      if (!LPAR()) return rejectInner();
      if (!expr()) return rejectInner();
      if (!RPAR()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  primary_2 = opttilde dfunc LPAR expr RPAR
  //-------------------------------------------------------------------
  private boolean primary_2()
    {
      begin("");
      opttilde();
      if (!dfunc()) return rejectInner();
      if (!LPAR()) return rejectInner();
      if (!expr()) return rejectInner();
      if (!RPAR()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  numexpr = number (BAR number)* {numexpr} ;
  //=====================================================================
  private boolean numexpr()
    {
      begin("numexpr");
      if (!number()) return reject();
      while (numexpr_0());
      sem.numexpr();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  numexpr_0 = BAR number
  //-------------------------------------------------------------------
  private boolean numexpr_0()
    {
      begin("");
      if (!BAR()) return rejectInner();
      if (!number()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  number = mantissa exponent? !point space {number} ;
  //=====================================================================
  private boolean number()
    {
      begin("number");
      if (!mantissa()) return reject();
      exponent();
      if (!number_0()) return reject();
      space();
      sem.number();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  number_0 = !point
  //-------------------------------------------------------------------
  private boolean number_0()
    {
      begin("","not '.' or ','");
      if (point()) return rejectNot();
      return acceptNot();
    }
  
  //=====================================================================
  //  mantissa = "." digits / digits ("." digits?)? ;
  //=====================================================================
  private boolean mantissa()
    {
      begin("mantissa");
      if (mantissa_0()) return accept();
      if (mantissa_1()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  mantissa_0 = "." digits
  //-------------------------------------------------------------------
  private boolean mantissa_0()
    {
      begin("");
      if (!next('.')) return rejectInner();
      if (!digits()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  mantissa_1 = digits ("." digits?)?
  //-------------------------------------------------------------------
  private boolean mantissa_1()
    {
      begin("");
      if (!digits()) return rejectInner();
      mantissa_2();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  mantissa_2 = "." digits?
  //-------------------------------------------------------------------
  private boolean mantissa_2()
    {
      begin("");
      if (!next('.')) return rejectInner();
      digits();
      return acceptInner();
    }
  
  //=====================================================================
  //  exponent = [Ee] sign? digits ;
  //=====================================================================
  private boolean exponent()
    {
      begin("exponent");
      if (!nextIn("Ee")) return reject();
      sign();
      if (!digits()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  sign = [+-] <sign> ;
  //=====================================================================
  private boolean sign()
    {
      begin("sign","sign");
      if (!nextIn("+-")) return reject();
      return accept();
    }
  
  //=====================================================================
  //  digits = digit+ ;
  //=====================================================================
  private boolean digits()
    {
      begin("digits");
      if (!digit()) return reject();
      while (digit());
      return accept();
    }
  
  //=====================================================================
  //  digit = [0-9] ;
  //=====================================================================
  private boolean digit()
    {
      begin("digit");
      if (!nextIn('0','9')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  word = ![0123456789_.,~] namechar+ ;
  //=====================================================================
  private boolean word()
    {
      begin("word");
      if (!aheadNotIn("0123456789_.,~")) return reject();
      if (!namechar()) return reject();
      while (namechar());
      return accept();
    }
  
  //=====================================================================
  //  namechar = ^[\t\n +-*/|^();#] <more name> ;
  //=====================================================================
  private boolean namechar()
    {
      begin("namechar","more name");
      if (!nextNotIn("\t\n +-*/|^();#")) return reject();
      return accept();
    }
  
  //=====================================================================
  //  point = [.,] <'.' or ','> ;
  //=====================================================================
  private boolean point()
    {
      begin("point","'.' or ','");
      if (!nextIn(".,")) return reject();
      return accept();
    }
  
  //=====================================================================
  //  opttilde = TILDE? <~> ;
  //=====================================================================
  private boolean opttilde()
    {
      begin("opttilde","~");
      TILDE();
      return accept();
    }
  
  //=====================================================================
  //  unitname = word space {&unitname} <unit name> ;
  //=====================================================================
  private boolean unitname()
    {
      begin("unitname","unit name");
      if (!word()) return reject();
      space();
      if (sem.unitname()) return accept();
      boolReject();
      return reject();
    }
  
  //=====================================================================
  //  bfunc = word space {&bfunc} <function name> ;
  //=====================================================================
  private boolean bfunc()
    {
      begin("bfunc","function name");
      if (!word()) return reject();
      space();
      if (sem.bfunc()) return accept();
      boolReject();
      return reject();
    }
  
  //=====================================================================
  //  dfunc = word space {&ufunc} <function name> ;
  //=====================================================================
  private boolean dfunc()
    {
      begin("dfunc","function name");
      if (!word()) return reject();
      space();
      if (sem.ufunc()) return accept();
      boolReject();
      return reject();
    }
  
  //=====================================================================
  //  BAR = "|" space <|> ;
  //=====================================================================
  private boolean BAR()
    {
      begin("BAR","|");
      if (!next('|')) return reject();
      space();
      return accept();
    }
  
  //=====================================================================
  //  HAT = "^" space <^> ;
  //=====================================================================
  private boolean HAT()
    {
      begin("HAT","^");
      if (!next('^')) return reject();
      space();
      return accept();
    }
  
  //=====================================================================
  //  TILDE = "~" space <~> ;
  //=====================================================================
  private boolean TILDE()
    {
      begin("TILDE","~");
      if (!next('~')) return reject();
      space();
      return accept();
    }
  
  //=====================================================================
  //  LPAR = "(" space <(> ;
  //=====================================================================
  private boolean LPAR()
    {
      begin("LPAR","(");
      if (!next('(')) return reject();
      space();
      return accept();
    }
  
  //=====================================================================
  //  MINUS = "-" space <-> ;
  //=====================================================================
  private boolean MINUS()
    {
      begin("MINUS","-");
      if (!next('-')) return reject();
      space();
      return accept();
    }
  
  //=====================================================================
  //  PLUS = "+" space <+> ;
  //=====================================================================
  private boolean PLUS()
    {
      begin("PLUS","+");
      if (!next('+')) return reject();
      space();
      return accept();
    }
  
  //=====================================================================
  //  RPAR = ")" space <)> ;
  //=====================================================================
  private boolean RPAR()
    {
      begin("RPAR",")");
      if (!next(')')) return reject();
      space();
      return accept();
    }
  
  //=====================================================================
  //  SLASH = "/" space </> ;
  //=====================================================================
  private boolean SLASH()
    {
      begin("SLASH","/");
      if (!next('/')) return reject();
      space();
      return accept();
    }
  
  //=====================================================================
  //  STARSTAR = "**" space <**> ;
  //=====================================================================
  private boolean STARSTAR()
    {
      begin("STARSTAR","**");
      if (!next("**")) return reject();
      space();
      return accept();
    }
  
  //=====================================================================
  //  STAR = "*" !"*" space <*> ;
  //=====================================================================
  private boolean STAR()
    {
      begin("STAR","*");
      if (!next('*')) return reject();
      if (!aheadNot('*')) return reject();
      space();
      return accept();
    }
  
  //=====================================================================
  //  PER = "per" !namechar space <'per'> ;
  //=====================================================================
  private boolean PER()
    {
      begin("PER","'per'");
      if (!next("per")) return reject();
      if (!PER_0()) return reject();
      space();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  PER_0 = !namechar
  //-------------------------------------------------------------------
  private boolean PER_0()
    {
      begin("","not more name");
      if (namechar()) return rejectNot();
      return acceptNot();
    }
  
  //=====================================================================
  //  space = [ \t]* {space} ;
  //=====================================================================
  private boolean space()
    {
      begin("space");
      while (nextIn(" \t"));
      sem.space();
      return accept();
    }
  
  //=====================================================================
  //  EOT = !_ <end of input> ;
  //=====================================================================
  private boolean EOT()
    {
      begin("EOT","end of input");
      if (!aheadNot()) return reject();
      return accept();
    }
  
}
